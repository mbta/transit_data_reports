# Glides Prediction Accuracy

```elixir
Mix.install(
  [
    {:atomic_map, "~> 0.9.3"},
    {:csv, "~> 3.2"},
    {:kino, "~> 0.12.0"},
    {:ex_aws, "~> 2.5"},
    {:ex_aws_s3, "~> 2.5"},
    {:hackney, "~> 1.20"},
    {:sweet_xml, "~> 0.7.4"},
    {:timex, "~> 3.7"},
    {:tzdata, "~> 1.1"},
    {:jaxon, "~> 2.0"}
  ],
  config: [
    ex_aws: [
      access_key_id: System.get_env("LB_AWS_ACCESS_KEY_ID"),
      secret_access_key: System.get_env("LB_AWS_SECRET_ACCESS_KEY"),
      region: "us-east-1"
    ]
  ]
)
```

## Load Data

### README

This report provides an implementation of https://www.notion.so/mbta-downtown-crossing/Rethinking-Prediction-Accuracy-for-Glides-e99561127b01490689135ab6b70cd33c

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
env_input =
  Kino.Input.select("Environment", [
    {"", "prod"},
    {"-dev-blue", "dev-blue"},
    {"-dev-green", "dev-green"},
    {"-dev", "dev"},
    {"-sandbox", "sandbox"}
  ])

yesterday_eastern = DateTime.now!("America/New_York") |> DateTime.to_date() |> Date.add(-1)
date_input = Kino.Input.date("Date", default: yesterday_eastern)

line_input =
  Kino.Input.select("Line", [
    {nil, "(Don't filter by line)"},
    {"Green Line", "Green Line"},
    {"Mattapan Line", "Mattapan Line"}
  ])

stop_id_input = Kino.Input.text("Stop ID")

limit_to_next_2_predictions_input = Kino.Input.checkbox("Consider next 2 predictions only")

[env_input, date_input, line_input, stop_id_input, limit_to_next_2_predictions_input]
|> Enum.each(&Kino.render/1)
```

## Function definitions

All the implementation logic for the report.

Collapse this section to skip to the procedure and outputs.

```elixir
defmodule GlidesReport.Settings do
  @moduledoc "User-selected settings for the report."

  @type t :: %__MODULE__{
          env_suffix: String.t(),
          date: Date.t(),
          line: String.t() | nil,
          stop_id: String.t() | nil,
          limit_to_next_2_predictions: boolean
        }

  defstruct [
    :env_suffix,
    :date,
    :line,
    :stop_id,
    :limit_to_next_2_predictions
  ]

  # Parses settings from input elements.
  def new(env, date, line, stop_id, limit_to_next_2_predictions) do
    %__MODULE__{
      env_suffix: Kino.Input.read(env),
      date: Kino.Input.read(date),
      line: Kino.Input.read(line),
      stop_id:
        case Kino.Input.read(stop_id) do
          "" -> nil
          id -> id
        end,
      limit_to_next_2_predictions: Kino.Input.read(limit_to_next_2_predictions)
    }
    |> tap(fn settings -> if is_nil(settings.date), do: raise("A date must be selected") end)
  end
end

defmodule GlidesReport.Util do
  # Streams all values from an ETS table. (Assuming table's objects are {key, value} 2-tuples)
  def stream_values(table) do
    :ets.first(table)
    |> Stream.iterate(fn key -> :ets.next(table, key) end)
    |> Stream.take_while(fn key -> key != :"$end_of_table" end)
    |> Stream.map(fn key -> :ets.lookup_element(table, key, 2) end)
  end

  def on_line?(nil, _route_id), do: true

  def on_line?("Green Line", route_id) do
    String.starts_with?(route_id, "Green-")
  end

  def on_line?("Mattapan Line", route_id) do
    route_id == "Mattapan"
  end

  def zero_pad(n, count \\ 2) do
    n
    |> Integer.to_string()
    |> String.pad_leading(count, "0")
  end

  def valid_trip_update?(tr_upd) do
    Enum.all?(
      [
        [:trip_update, :trip, :route_id],
        [:trip_update, :stop_time_update, Access.all(), :stop_id],
        [:trip_update, :timestamp]
      ],
      &(not is_nil(get_in(tr_upd, &1)))
    )
  end

  def filter_stops(tr_upd, stop_id) do
    case filter_stops_by_stop_id(tr_upd, stop_id) do
      nil ->
        nil

      tr_upd ->
        update_in(tr_upd.trip_update.stop_time_update, fn stop_time_update ->
          Enum.reject(stop_time_update, &is_nil(get_in(&1, [:departure, :time])))
        end)
    end
  end

  # Removes, from a trip update's stop_time_update, all entries that don't apply to the target stop.
  # Returns nil if trip update doesn't contain the target stop anywhere in its stop_time_update.
  defp filter_stops_by_stop_id(tr_upd, nil), do: tr_upd

  defp filter_stops_by_stop_id(tr_upd, stop_id) do
    tr_upd.trip_update.stop_time_update
    |> Enum.find(&(&1.stop_id == stop_id))
    |> case do
      nil ->
        nil

      target_stop_time_update ->
        put_in(tr_upd.trip_update.stop_time_update, [target_stop_time_update])
    end
  end

  def valid_vehicle_position?(ve_pos) do
    Enum.all?(
      [
        [:vehicle, :trip, :route_id],
        [:vehicle, :trip, :trip_id],
        [:vehicle, :current_status],
        [:vehicle, :stop_id]
      ],
      &(not is_nil(get_in(ve_pos, &1)))
    )
  end

  def vehicle_at_stop?(_status_stop, nil), do: true

  def vehicle_at_stop?(status_stop, stop_id) do
    match?({"STOPPED_AT", ^stop_id}, status_stop)
  end

  # Converts a nonempty list of KW-lists, e.g.:
  # [
  #   [{"headerA", "valueA1"}, {"headerB", "valueB1"}],
  #   [{"headerA", "valueA2"}, {"headerB", "valueB2"}]
  # ]
  # to a CSV string.
  def table_to_csv(table) do
    table
    |> Stream.map(&Map.new/1)
    |> CSV.encode(headers: Enum.map(hd(table), &elem(&1, 0)), delimiter: "\n")
    |> Enum.join()
  end

  def build_csv_name(table_name, settings) do
    %{
      env_suffix: env_suffix,
      date: date,
      line: line,
      stop_id: stop_id,
      limit_to_next_2_predictions: limit_to_next_2_predictions
    } = settings

    env = if env_suffix == "", do: "prod", else: String.slice(env_suffix, 1..-1//1)

    optionals =
      [
        {line, "line=#{line}"},
        {stop_id, "stop_id=#{stop_id}"},
        {limit_to_next_2_predictions, "next 2 predictions only"}
      ]
      |> Enum.filter(&elem(&1, 0))
      |> Enum.map(&elem(&1, 1))
      |> Enum.join(",")
      |> case do
        "" -> ""
        str -> ",#{str}"
      end

    "Glides report - #{table_name} - #{env},#{date}#{optionals}.csv"
  end
end

defmodule GlidesReport.Loader do
  def load_data(date, env_suffix) do
    set_up_table(:TripUpdates)
    set_up_table(:VehiclePositions)

    # Create the inferred start and end times:
    start_time = DateTime.new!(date, Time.new!(4, 0, 0), "America/New_York")

    end_time =
      DateTime.new!(date, Time.new!(3, 59, 59), "America/New_York")
      # Can be replaced with DateTime.shift/2 once Livebook runs on Elixir 1.17+
      |> Timex.shift(days: 1)

    # Calculate the total number of 5-minute increments in a day
    total_increments = div(DateTime.diff(end_time, start_time, :minute), 5)

    # Shift start_time to UTC to align with the UTC timestamps used in our S3 object names
    start_time_utc = DateTime.shift_zone!(start_time, "Etc/UTC")

    # Create list of file prefixes for each 5-minute increment
    files =
      Enum.map(0..total_increments, fn increment ->
        start_time_utc
        |> DateTime.add(increment * 5, :minute)
        |> Calendar.strftime("%Y/%m/%d/%Y-%m-%dT%H:%M")
      end)

    frame = Kino.Frame.new() |> Kino.render()

    [
      populate_table(:TripUpdates, files, env_suffix),
      populate_table(:VehiclePositions, files, env_suffix)
    ]
    |> Enum.each(fn table -> Kino.Frame.append(frame, table) end)
  end

  # Loads data into a table and creates a UI element representing the table.
  defp populate_table(table_name, files, env_suffix) do
    files
    |> Task.async_stream(&download_file(&1, table_name, env_suffix), max_concurrency: 15)
    |> Stream.run()

    Kino.ETS.new(table_name)
  end

  # Downloads a VehiclePosition or TripUpdate file and loads it into ETS.
  defp download_file(remote_prefix, table_name, env_suffix) do
    all_objects =
      ExAws.S3.list_objects("mbta-gtfs-s3#{env_suffix}", prefix: remote_prefix)
      |> ExAws.stream!()
      |> Enum.to_list()

    remote_path =
      Enum.find_value(all_objects, fn obj ->
        if String.contains?(obj.key, "https_cdn.mbta.com_realtime_#{table_name}_enhanced.json"),
          do: obj.key
      end)

    # Files are downloaded to a temp directory.
    local_path =
      remote_path
      |> Path.split()
      |> Enum.take(-1)
      |> then(&Path.join(System.tmp_dir!(), &1))

    if File.exists?(local_path) do
      IO.inspect("File already exists, skipping download: #{local_path}")
    else
      IO.inspect("Downloading #{remote_path} to #{local_path}...")

      ExAws.S3.download_file("mbta-gtfs-s3", remote_path, local_path)
      |> ExAws.request()
    end

    json_data =
      File.stream!(local_path, [:compressed])
      |> Jaxon.Stream.from_enumerable()

    timestamp =
      json_data
      |> Jaxon.Stream.query([:root, "header", "timestamp"])
      |> Enum.to_list()
      |> List.first()

    json_data
    |> Jaxon.Stream.query([:root, "entity", :all])
    |> Stream.each(fn obj ->
      :ets.insert(
        table_name,
        {"#{timestamp}_#{obj["id"]}", AtomicMap.convert(obj, safe: false, underscore: false)}
      )
    end)
    |> Stream.run()

    {remote_path, local_path}
  end

  # Creates or clears an ETS table.
  defp set_up_table(table) do
    if :ets.whereis(table) != :undefined,
      do: :ets.delete_all_objects(table),
      else: :ets.new(table, [:named_table, :public])
  end
end

# Applying the next-2-stops-only filter is somewhat involved.
# The following 2 modules are only relevant for when that filter is enabled.
defmodule GlidesReport.Sign do
  @moduledoc "Simulates a countdown clock at one platform (child stop ID)."

  @type t :: %__MODULE__{
          predictions: list({trip_id :: String.t(), departure_time :: integer}),
          top_twos: MapSet.t(trip_id :: String.t())
        }

  defstruct predictions: [], top_twos: MapSet.new()

  def new, do: %__MODULE__{}

  def new(trip_id, departure_time, timestamp) when departure_time >= timestamp do
    %__MODULE__{
      predictions: [{trip_id, departure_time}],
      top_twos: MapSet.new([trip_id])
    }
  end

  def new(_trip_id, _departure_time, _timestamp), do: new()

  def apply_skipped_trip(sign, trip_id, timestamp) do
    sign = advance_to_time(sign, timestamp)

    update_in(sign.predictions, fn predictions ->
      Enum.reject(predictions, &match?({^trip_id, _}, &1))
    end)
    |> update_top_twos()
  end

  def apply_stop_time_update(sign, trip_id, departure_time, timestamp) do
    sign = advance_to_time(sign, timestamp)

    update_in(sign.predictions, fn predictions ->
      predictions
      |> replace_or_append(&match?({^trip_id, _}, &1), {trip_id, departure_time})
      |> Enum.sort_by(fn {_, ts} -> ts end)
    end)
    |> update_top_twos()
  end

  def update_top_twos(sign) do
    update_in(sign.top_twos, fn top_twos ->
      sign.predictions
      |> Enum.take(2)
      |> Enum.reduce(top_twos, fn {trip_id, _}, top_twos -> MapSet.put(top_twos, trip_id) end)
    end)
  end

  # Simulate time passing until the next timestamped trip update comes in.
  defp advance_to_time(sign, timestamp) do
    {before, not_before} = Enum.split_while(sign.predictions, fn {_, ts} -> ts < timestamp end)
    seen = before ++ Enum.take(not_before, 2)
    seen_trip_ids = MapSet.new(seen, &elem(&1, 0))

    sign = put_in(sign.predictions, not_before)
    sign = update_in(sign.top_twos, &MapSet.union(&1, seen_trip_ids))
    sign
  end

  defp replace_or_append([], _predicate?, value), do: [value]

  defp replace_or_append([h | t], predicate?, value) do
    if predicate?.(h),
      do: [value | t],
      else: [h | replace_or_append(t, predicate?, value)]
  end
end

defmodule GlidesReport.CountdownClocksSimulation do
  @moduledoc "Simulates countdown clock signs."

  alias GlidesReport.{Sign, Util}

  @type t :: %{(stop_id :: String.t()) => Sign.t()}
  def get_all_top_two_trips(stop_id, line) do
    trip_updates_for_simulation(stop_id, line)
    |> Enum.reduce(%{}, fn tr_upd, signs -> apply_trip_update(signs, tr_upd) end)
    |> Stream.map(fn {_stop_id, sign} -> sign.top_twos end)
    |> Enum.reduce(MapSet.new(), &MapSet.union/2)
  end

  def apply_trip_update(signs, tr_upd)
      when tr_upd.trip_update.trip.schedule_relationship == "CANCELED" do
    trip_id = tr_upd.id
    timestamp = tr_upd.trip_update.timestamp

    Map.new(signs, fn {stop_id, sign} ->
      {stop_id, Sign.apply_skipped_trip(sign, trip_id, timestamp)}
    end)
  end

  def apply_trip_update(signs, tr_upd) do
    trip_id = tr_upd.id
    timestamp = tr_upd.trip_update.timestamp

    Enum.reduce(tr_upd.trip_update.stop_time_update, signs, fn
      %{schedule_relationship: "SKIPPED"} = stop_time_update, signs ->
        Map.update(
          signs,
          stop_time_update.stop_id,
          Sign.new(),
          &Sign.apply_skipped_trip(&1, trip_id, timestamp)
        )

      stop_time_update, signs ->
        departure_time = stop_time_update.departure.time

        Map.update(
          signs,
          stop_time_update.stop_id,
          Sign.new(trip_id, departure_time, timestamp),
          &Sign.apply_stop_time_update(&1, trip_id, departure_time, timestamp)
        )
    end)
  end

  defp trip_updates_for_simulation(stop_id, line) do
    :TripUpdates
    |> Util.stream_values()
    |> Stream.filter(&valid_trip_update_for_simulation?/1)
    # Apply line filter
    |> Stream.filter(fn tr_upd ->
      line && Util.on_line?(line, tr_upd[:trip_update][:trip][:route_id])
    end)
    # Filter each trip update's stop_time_update list.
    # If a stop filter is set, apply it.
    # Also remove any entries that don't have a .departure.time value.
    # If filtered list is empty for any trip update, the trip update is removed entirely.
    |> Stream.map(&filter_stops_for_simulation(&1, stop_id))
    |> Stream.reject(&is_nil/1)
    |> Enum.sort_by(& &1.trip_update.timestamp)
  end

  defp valid_trip_update_for_simulation?(tr_upd) do
    tr_upd[:trip_update][:timestamp] != nil
  end

  defp filter_stops_for_simulation(tr_upd, stop_id) do
    tr_upd
    |> filter_stops_by_stop_id_for_simulation(stop_id)
    |> case do
      nil ->
        nil

      tr_upd when tr_upd.trip_update.trip.schedule_relationship == "CANCELED" ->
        tr_upd

      tr_upd ->
        update_in(tr_upd.trip_update.stop_time_update, fn stop_time_update ->
          Enum.reject(stop_time_update, &is_nil(get_in(&1, [:departure, :time])))
        end)
    end
  end

  defp filter_stops_by_stop_id_for_simulation(tr_upd, stop_id)
       when is_nil(stop_id)
       when tr_upd.trip_update.trip.schedule_relationship == "CANCELED" do
    tr_upd
  end

  defp filter_stops_by_stop_id_for_simulation(tr_upd, stop_id) do
    tr_upd.trip_update.stop_time_update
    |> Enum.find(&(&1.stop_id == stop_id))
    |> case do
      nil ->
        nil

      target_stop_time_update ->
        put_in(tr_upd.trip_update.stop_time_update, [target_stop_time_update])
    end
  end
end

:ok
```

## Main procedure

Read inputs

```elixir
settings =
  GlidesReport.Settings.new(
    env_input,
    date_input,
    line_input,
    stop_id_input,
    limit_to_next_2_predictions_input
  )
```

Load data into ETS tables

```elixir
GlidesReport.Loader.load_data(settings.date, settings.env_suffix)
```

### Filter trip updates

```elixir
trip_updates =
  :TripUpdates
  |> GlidesReport.Util.stream_values()
  |> Stream.filter(&GlidesReport.Util.valid_trip_update?/1)
  # Apply line filter
  |> Stream.filter(fn tr_upd ->
    GlidesReport.Util.on_line?(settings.line, tr_upd.trip_update.trip.route_id)
  end)
  # Filter each trip update's stop_time_update list.
  # If a stop filter is set, apply it.
  # Also remove any entries that don't have a .departure.time value.
  # If filtered list is empty for any trip update, the trip update is removed entirely.
  |> Stream.map(&GlidesReport.Util.filter_stops(&1, settings.stop_id))
  |> Stream.reject(&is_nil/1)

trip_updates =
  if settings.limit_to_next_2_predictions do
    top_twos =
      GlidesReport.CountdownClocksSimulation.get_all_top_two_trips(
        settings.stop_id,
        settings.line
      )

    Stream.filter(trip_updates, &(&1.id in top_twos))
  else
    trip_updates
  end
```

### Filter Vehicle Positions

```elixir
vehicle_positions =
  :VehiclePositions
  |> GlidesReport.Util.stream_values()
  |> Stream.filter(&GlidesReport.Util.valid_vehicle_position?/1)
  # We only care about when a vehicle is stopped at a stop.
  |> Stream.filter(&(&1.vehicle.current_status == "STOPPED_AT"))
  |> Stream.filter(fn ve_pos ->
    GlidesReport.Util.on_line?(settings.line, ve_pos.vehicle.trip.route_id)
  end)
  |> Stream.filter(fn ve_pos ->
    GlidesReport.Util.vehicle_at_stop?(
      {ve_pos.vehicle.current_status, ve_pos.vehicle.stop_id},
      settings.stop_id
    )
  end)
```

## Per-Hour Counts of trips for which RTR made departure predictions vs. actual departures

```elixir
unix_timestamp_to_local_hour = fn timestamp ->
  timestamp
  |> DateTime.from_unix!()
  |> DateTime.shift_zone!("America/New_York")
  |> then(& &1.hour)
end

predicted_departures_by_hour =
  trip_updates
  # Group by hour of the predicted departure (not hour the prediction was generated!),
  # in local time.
  # This requires splitting each trip update into its individual stop_time_update items.
  |> Stream.flat_map(fn tr_upd ->
    Enum.map(
      tr_upd.trip_update.stop_time_update,
      &%{trip_id: tr_upd.id, departure_time: &1.departure.time}
    )
  end)
  |> Enum.group_by(
    &unix_timestamp_to_local_hour.(&1.departure_time),
    & &1.trip_id
  )
  |> Map.new(fn {hour, trip_ids} -> {hour, MapSet.new(trip_ids)} end)

actual_departures_by_hour =
  vehicle_positions
  # Group by hour
  |> Enum.group_by(
    &unix_timestamp_to_local_hour.(&1.vehicle.timestamp),
    & &1.vehicle.trip.trip_id
  )
  |> Map.new(fn {hour, trip_ids} -> {hour, MapSet.new(trip_ids)} end)

table1 =
  0..23
  # Service day starts at 4am, so let's start the table at that hour.
  |> Enum.map(&rem(&1 + 4, 24))
  |> Enum.map(fn hour ->
    predicted_departure_trips = Map.get(predicted_departures_by_hour, hour, MapSet.new())
    actual_departure_trips = Map.get(actual_departures_by_hour, hour, MapSet.new())

    [
      {"hour", "#{GlidesReport.Util.zero_pad(hour)}:00"},
      {"# of predicted departure trips", MapSet.size(predicted_departure_trips)},
      {"# of actual departure trips", MapSet.size(actual_departure_trips)}
    ]
  end)

table_name = "Predicted vs actual departures"

Kino.Download.new(
  fn -> GlidesReport.Util.table_to_csv(table1) end,
  filename: GlidesReport.Util.build_csv_name(table_name, settings),
  label: "Export as CSV"
)
|> Kino.render()

Kino.DataTable.new(table1, name: table_name)
```

## Per-Hour % of trips for which RTR made departure predictions vs. actual departures

```elixir
table2 =
  0..23
  # Service day starts at 4am, so let's start the table at that hour.
  |> Enum.map(&rem(&1 + 4, 24))
  |> Enum.map(fn hour ->
    predicted_departures = Map.get(predicted_departures_by_hour, hour, MapSet.new())
    actual_departures = Map.get(actual_departures_by_hour, hour, MapSet.new())

    # *** For reviewer: ***
    # This does trip matching, which the ticket description said is not needed.
    # I'm not sure how else to interpret the requested metric, though--am I
    # misunderstanding it, or is the ticket description incorrect?
    actual_departures_with_predictions =
      MapSet.intersection(predicted_departures, actual_departures)

    actual_departure_count = MapSet.size(actual_departures)
    actual_departure_with_prediction_count = MapSet.size(actual_departures_with_predictions)

    percentage =
      if actual_departure_count > 0 do
        p = round(100.0 * (actual_departure_with_prediction_count / actual_departure_count))
        "#{p}%"
      else
        "N/A (0 actual departures)"
      end

    [
      {"hour", "#{GlidesReport.Util.zero_pad(hour)}:00"},
      {"% of actual departure trips that had predictions", percentage}
    ]
  end)

table_name = "Percent of departures with predictions"

Kino.Download.new(
  fn -> GlidesReport.Util.table_to_csv(table2) end,
  filename: GlidesReport.Util.build_csv_name(table_name, settings),
  label: "Export as CSV"
)
|> Kino.render()

Kino.DataTable.new(table2, name: table_name)
```

## Data Structure

Some typespecs to document the data structures we're working with.

```elixir
defmodule Common do
  @moduledoc "Shared types."

  @type stop_id :: String.t()
  @type route_id :: String.t()
  @type trip_id :: String.t()
  @type vehicle_id :: String.t()

  # Unix epoch timestamp
  @type timestamp :: integer

  # e.g. "20240603"
  @type date_string :: String.t()

  # e.g. "09:18:50"
  @type time_string :: String.t()
end

defmodule TripUpdate do
  @moduledoc "Structure of an entry in the :TripUpdates table."

  @type t :: {key, value}

  # Key is a string of the form "#{timestamp}_#{trip_id}"
  # e.g. "1717524600_62216363"
  # NB: This timestamp can be different from .trip_update.timestamp,
  # it appears to be the time this snapshot was stored while
  # .trip_update.timestamp is the time that the trip update was generated.
  @type key :: String.t()

  @type value :: %{
          # ID of trip being updated.
          id: Common.trip_id(),
          trip_update: %{
            optional(:vehicle) => %{id: Common.vehicle_id()},
            optional(:update_type) => update_type,
            # Time at which this trip update was generated.
            # Field *sometimes* not present if trip.schedule_relationship is "CANCELED"
            # Field not present if update_type is "reverse_trip"
            optional(:timestamp) => Commmon.timestamp(),
            # Field not present if trip.schedule_relationship is "CANCELED"
            optional(:stop_time_update) => [
              %{
                # Field not present if schedule_relationship is "SKIPPED"
                optional(:departure) => %{time: Commmon.timestamp(), uncertainty: integer},
                # Field not present if schedule_relationship is "SKIPPED"
                optional(:arrival) => %{time: Commmon.timestamp(), uncertainty: integer},
                optional(:schedule_relationship) => stop_time_schedule_relationship,
                stop_id: Commmon.stop_id(),
                # index of this stop in the sequence, starting with 1
                stop_sequence: pos_integer
              }
            ],
            trip: %{
              optional(:schedule_relationship) => trip_schedule_relationship,
              trip_id: Commmon.trip_id(),
              direction_id: 0 | 1,
              last_trip: boolean,
              revenue: boolean,
              route_id: Commmon.route_id(),
              start_date: Commmon.date_string(),
              start_time: Commmon.time_string()
            }
          }
        }

  # "mid_trip" | "reverse_trip" | "at_terminal"
  @type update_type :: String.t()

  @type trip_update_id :: String.t()

  # "CANCELED" | "ADDED"
  @type trip_schedule_relationship :: String.t()

  # "SKIPPED"
  @type stop_time_schedule_relationship :: String.t()
end

defmodule VehiclePosition do
  @moduledoc "Structure of an entry in the :VehiclePositions table."

  @type t :: {key, value}

  # Key is a string of the form "#{timestamp}_#{vehicle_id}"
  # e.g. "1717471500_G-10351"
  @type key :: String.t()

  @type value :: %{
          # Same ID as in the second part of key
          # e.g. "G-10351"
          id: Common.vehicle_id(),
          vehicle: %{
            optional(:stop_id) => Commmon.stop_id(),
            # unused for this report
            optional(:multi_carriage_details) => [
              %{
                # index of this carriage in the sequence, starting with 1
                carriage_sequence: pos_integer,
                # carriage ID maybe?
                label: String.t(),
                occupancy_status: occupancy_status,
                orientation: carriage_orientation
              }
            ],
            current_status: status,
            # index of the stop it's at or approaching
            current_stop_sequence: integer,
            # unused for this report
            position: %{
              # compass direction in degrees
              bearing: integer,
              latitude: float,
              longitude: float,
              speed: float
            },
            timestamp: Commmon.timestamp(),
            trip: %{
              direction_id: 0 | 1,
              last_trip: boolean,
              revenue: boolean,
              route_id: Commmon.route_id(),
              schedule_relationship: String.t(),
              start_date: Commmon.date_string(),
              start_time: Commmon.time_string(),
              trip_id: Commmon.trip_id()
            },
            vehicle: %{
              id: Common.vehicle_id(),
              # Formed by joining multi_carriage_details[].label with "-"
              # e.g. "3682-3849"
              label: String.t()
            }
          }
        }

  # "IN_TRANSIT_TO" | "STOPPED_AT" | "INCOMING_AT"
  @type status :: String.t()

  # "NO_DATA_AVAILABLE" | "STANDING_ROOM_ONLY" | "FEW_SEATS_AVAILABLE"
  # | "MANY_SEATS_AVAILABLE" | "CRUSHED_STANDING_ROOM_ONLY"
  @type occupancy_status :: String.t()

  # "AB" | "BA"
  @type carriage_orientation :: String.t()
end
```

<!-- livebook:{"offset":25083,"stamp":{"token":"XCP.hNETl0GEnTjs7KRyBEqlIwlNKHpCpoEwD6LyhIS6I2DcWIojSw-B64Ih605jOJTgWMj4pgjVuqgMPBg_NnVbYavMU3vWC7E1CXVLgH56n8uZuokNgx2g6btS5q-8iQ0t4h9FsXXNtUn3cW68iv6r4kcFW_M7aw","version":2}} -->
